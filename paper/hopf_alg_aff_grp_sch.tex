% !TeX program = xelatex
% !TEX options = --shell-escape paper/hopf_alg_aff_grp_sch.tex
\documentclass{article}

\title{Correspondence of affine group schemes and Hopf algebras in Lean 4}
\author{Ya√´l Dillies, Micha≈Ç Mruga≈Ça, Andrew Yang\footnote{All authors contributed equally to this work.}}
\date{\today}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{mathtools}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{mathrsfs}
\usepackage{parskip}
\usepackage{relsize}
\usepackage[hypcap=true]{caption}
\usepackage[shortlabels]{enumitem}
\usepackage{hyperref}

\usepackage[capitalise,noabbrev]{cleveref}
\usepackage{nameref}
\usepackage[margin=1in,a4paper]{geometry}

%%% Lean listings setup %%%

\usepackage{fontspec}
\usepackage{minted}

% JuliaMono has all the symbols needed for Lean code
\setmonofont[Scale=MatchLowercase]{JuliaMono}[
  Extension=.ttf,
  UprightFont=*-Regular,
  BoldFont=*-Bold,
  ItalicFont=*-RegularItalic,
  BoldItalicFont=*-BoldItalic,
  RawFeature={-calt},
]

% autogobble lets us indent the lean code to distinguish it from the latex
\setminted{frame=single}
\newmintinline[lean]{lean}{breaklines,breakbefore={. },breakafter={_}}
\newminted[leancode]{lean}{autogobble}

% Configure the appearance of minted.
% We adjust the spacing around minted environments, which stretches badly by default
\fvset{listparameters=\setlength{\topsep}{0pt}\setlength{\parsep}{0pt}}
\AtBeginEnvironment{minted}{\vspace{4pt}}
\renewcommand{\floatpagefraction}{.99}
\renewcommand{\bottomfraction}{.7}

%%% Lean listings setup %%%

% Theorems
\newtheorem{thm}{Theorem}[section]
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{corollary}[thm]{Corollary}
\newtheorem{dfn}[thm]{Definition}
\newtheorem{eg}[thm]{Example}
\newtheorem{egs}[thm]{Examples}
\newtheorem{conj}{Conjecture}
\newtheorem{prob}[thm]{Problem}
\newtheorem{question}{Question}

% Command redirections
\let\P\oldP
\let\oldemptyset\emptyset
\let\emptyset\varnothing

% Letter shorthands
\newcommand{\C}{\mathbb C}
\newcommand{\bbE}{\mathbb E}
\newcommand{\F}{\mathbb F}
\newcommand{\K}{\mathbb K}
\newcommand{\N}{\mathbb N}
\newcommand{\Q}{\mathbb Q}
\newcommand{\R}{\mathbb R}
\newcommand{\Z}{\mathbb Z}
\newcommand{\mcA}{\mathcal A}
\newcommand{\mcB}{\mathcal B}
\newcommand{\mcC}{\mathcal C}
\newcommand{\mcD}{\mathcal D}
\newcommand{\mcE}{\mathcal E}
\newcommand{\mcF}{\mathcal F}
\newcommand{\mcG}{\mathcal G}
\newcommand{\mcH}{\mathcal H}
\newcommand{\mcM}{\mathcal M}
\newcommand{\mcN}{\mathcal N}
\newcommand{\mcO}{\mathcal O}
\newcommand{\mcP}{\mathcal P}
\newcommand{\mcQ}{\mathcal Q}
\newcommand{\mcR}{\mathcal R}
\newcommand{\mcS}{\mathcal S}
\newcommand{\mcT}{\mathcal T}
\newcommand{\mcU}{\mathcal U}
\newcommand{\mcV}{\mathcal V}
\newcommand{\eps}{\varepsilon}
\newcommand{\Eps}{\mathcal E}
\newcommand{\Homgr}{\Hom_{\mathrm{gr}}}
\newcommand{\Homcogr}{\Hom_{\mathrm{cogr}}}


\DeclareMathOperator{\Hom}{Hom}
\DeclareMathOperator{\Set}{Set}
\DeclareMathOperator{\Ring}{Ring}
\DeclareMathOperator{\Alg}{Alg}
\DeclareMathOperator{\CommRing}{CommRing}
\DeclareMathOperator{\CommAlg}{CommAlg}
\DeclareMathOperator{\CommBialg}{CommBialg}
\DeclareMathOperator{\CommHopfAlg}{CommHopfAlg}


\begin{document}


\maketitle


\begin{abstract}
  We formalise the correspondence between affine group schemes and Hopf algebras in Lean 4.
  For a field $k$, we show that the category of affine group $k$-schemes is equivalent
  to the category of commutative Hopf algebras over $k$.
  As an application, we construct the perfect pairing of characters and cocharacters of a split torus over a field.
  Our work is largely a reproduction of \cite{CrazyAffine},
  with the major difference being that we work with group objects
  as defined by the usual diagrams as opposed to presheaves of groups.
  Our code is made available as part of Mathlib, the Lean 4 library of formalised mathematics.
\end{abstract}


\section{Introduction}\label{sec:intro}


Algebraic groups are a central object of study in algebraic geometry. {\bf TODO: Expand}

Hopf algebras ... {\bf TODO: Expand}

Since we have no use for not necessarily commutative rings, we drop henceforth the ``commutative'' prefix in front of ``ring'', ``algebra'', ``bialgebra'', ``Hopf algebra''.
We keep ``Comm'' in the names of our categories, for consistency with the Lean code.

Lean is an interactive theorem prover and functional programming language. {\bf TODO: Expand}

Here is a sample of Lean code, claiming that composition of morphisms is associative:
\begin{leancode}
  variable {ùíû : Type u} [Category.{v} ùíû] {W X Y Z : ùíû}

  lemma comp_assoc (f : W ‚ü∂ X) (g : X ‚ü∂ Y) (h : Y ‚ü∂ Z) : f ‚â´ (g ‚â´ h) = (f ‚â´ g) ‚â´ h := ...
\end{leancode}

\lean{variable} is a keyword to introduce variables.
The combination \lean{{ùíû : Type u} [Category.{v} ùíû]} translates to ``Let $\mcC$ be a category with objects and morphisms in the $u$-th and $v$-th universes respectively''.
We will not have much use of universes and therefore will explain them no further.
All there is to know is that the categories relevant to the present paper have $u = v + 1$, corresponding to the fact that their objects form a proper class and their hom sets $X \to Y$ truly are sets.
\lean{{W X Y Z : ùíû}} declares $W, X, Y, Z$ as objects in the category $\mcC$, and \lean{(f : W ‚ü∂ X) (g : X ‚ü∂ Y) (h : Y ‚ü∂ Z)} declares morphisms between them.
\lean{f ‚â´ g} represents composition of morphisms, with the twist that the morphism $f$ is applied first, as opposed to the usual function composition notation \lean{g ‚àò f}.
\lean{...} is not valid Lean syntax, but instead a placeholder we use throughout this paper to elide irrelevant details.
The full code for code snippets in each section is available on GitHub. See \url{https://github.com/YaelDillies/Toric/tree/master/HopfAlgAffGrpSchPaper}.

Our motivation for this work is not correctness.
Certainly, the material we formalise is part of the standard algebraic geometry curriculum and is correct without a doubt.
Our goal is instead to clear the prerequisites to more advanced topics, such as toric varieties.
In fact, we started off formalising toric varieties within the Toric project
\footnote{Available on GitHub. See \url{https://yaeldillies.github.io/Toric/}.}
before quickly realising that we first needed a solid theory of algebraic tori, which itself is most conveniently expressed in the language of group schemes.
Simultaneously, group schemes are needed for Kevin Buzzard's ongoing project to formalise Fermat's Last Theorem in Lean.
\footnote{Available on GitHub. See \url{https://imperialcollegelondon.github.io/FLT/}.}

The paper is structured as follows:
\cref{sec:informal} provides the mathematical background necessary to understand the formalisation.
\cref{sec:hopf,sec:concrete-categories,sec:grp,sec:yoneda} illustrate the design decisions we made, specific painpoints we identified and how we circumvented them, all grouped according to the relevant mathematical concepts.
These developments culminate in the definition of the perfect pairing between characters and cocharacters of an algebraic group, as described in \cref{sec:char-cochar}.


\section{The character-cocharacter pairing}\label{sec:char-cochar}


TODO(Micha≈Ç)



\section{The correspondence between affine group schemes and Hopf algebras}


In \cref{sec:char-cochar}, we reduced the existence of the character-cocharacter pairing
to the computation of the group $\Homgr(\Spec R[H], \Spec R[G])$
where $G$ and $H$ are commutative groups as the group $\Homgr(G, H)$.
In this section, we compute this hom set in two main steps.

First, we make every commutative group algebra $R[G]$
into a cogroup object in the category of algebras.
This involves finding a \emph{counit} $\eps : R[G] \to R$,
a \emph{comultiplication} $\delta : R[G] \to R[G \times G]$
and an \emph{antipode} $\iota : R[G] \to R[G]$
respecting the axioms of a group object, but with all arrows reversed:

TODO: Insert diagram

As a result, we acquire a notion of "cogroup homomorphism":
An algebra homomorphism $f : R[G] \to R[H]$ will be a \emph{cogroup homomorphism} iff
it commutes with counit and comultiplication
(at which point it automatically commutes with antipode too).
Just as for regular groups, cogroup homomorphisms form a group under pointwise comultiplication.
We call the product of two cogroup homomorphisms the \emph{convolution product}.
By abstract nonsense, this means that $\Homgr(\Spec R[H], \Spec R[G])$ is isomorphic as a group to
$R$-cogroup homomorphisms $\Homcogr(R[G], R[H])$ under the convolution product.

Second, by algebra we prove that every said $R$-cogroup homomorphisms $R[G] \to R[H]$
comes from a unique group homomorphism $G \to H$,
in a way that sends the convolution product to the pointwise product of group homomorphisms.

The first main step can in fact be carried out for more general objects than group algebras.
The cogroup structure we endowed $R[G]$ with is exactly the data required
to make $R[G]$ into a (cocommutative) \emph{$R$-Hopf algebra}.
\footnote{We have no use of non-cocommutative Hopf algebras in this paper,
therefore we always assume that $\beta \circ \delta = \delta$.}
We will in fact execute the whole step
relative to two $R$-Hopf algebras $A$ and $B$ in place of $R[G]$ and $R[H]$.
In what follows, \emph{Hopf algebra homomorphisms} will replace what we called so far
"cogroup homomorphisms".
Simultaneously, one can attempt to remove the antipode from the definition of Hopf algebra.
The resulting concept is called a \emph{bialgebra},
bialgebra homomorphisms have the same definition as Hopf algebra homomorphisms,
and as a result bialgebras are exactly the comonoid objects in the category of algebras.
If one further removes the $R$-algebra structure from bialgebras,
then one obtains \emph{coalgebras}.

In the remainder of this section,
we detail how we implemented the convolution product (\cref{sec:conv-prod}),
how to deal with/automate routine computations in Hopf algebras (\cref{sec:coassoc-simps})
and finally how to translate between the concrete description of a Hopf algebra in terms
of linear maps and the categorical machinery of cogroup objects (\cref{sec:concrete-categories}).
We relegate the abstract nonsense itself to \cref{sec:abstract-nonsense}.


\subsection{Convolution product}\label{sec:conv-prod}



\subsection{A tactic for Hopf algebra tautologies}



\subsection{The role of concrete categories}\label{sec:concrete-categories}



\section{Abstract nonsense}\section{sec:abstract-nonsense}


TODO(Ya√´l)


\subsection{A tactic for Hopf algebra tautologies}\label{sec:coassoc-simps}


TODO(Andrew): coassoc simps


\subsection{Concrete categories}\label{sec:concrete-categories}


TODO(Ya√´l)


\subsection{\texorpdfstring{$\CommBialg, \CommHopfAlg$}{CommBialg, CommHopfAlg}}\label{sec:comm-hopf-alg}


TODO(Ya√´l)



\section{Abstract nonsense}\section{sec:abstract-nonsense}


\subsection{Fully faithful functors on monoid objects}


TODO(Ya√´l): mapMon, Essential image computation


\subsection{The Yoneda embedding}


TODO(Andrew)


\subsection{Cartesian-monoidal categories}


TODO(Ya√´l): Monoidal functors, CartesianMonoidalCategory


\subsection{A tactic for monoid object tautologies}


TODO(Ya√´l): mon_tauto


\section{Diagonalisable group schemes}


TODO(Micha≈Ç)


\section{The special orthogonal group in 2D}


TODO(Micha≈Ç)



\section{REWORK FROM HERE}


\section{Informal description of the correspondence}\label{sec:informal}


In this section, we explain the mathematics behind the correspondence.
Before we get into the details, here's a summary of how the story goes.
Definitions and detailed explanations will follow

For $R$ a commutative ring, the \emph{prime spectrum} of $R$ is the set of prime ideals of $R$,
made into a scheme denoted $\Spec R$.
$\Spec$ is in fact a \emph{contravariant functor} from commutative rings to schemes:
For $f : R \to S$, we get a corresponding morphism $\Spec f : \Spec S \to \Spec R$
at the level of schemes, obtained by taking the preimage of each prime ideal.
Furthermore, $\Spec$ is \emph{fully faithful},
meaning that $f \mapsto \Spec f$ is a bijection for all $R, S$.

These properties together show that one can lift $\Spec$ to a functor on commutative $R$-algebras:
If $A$ is a commutative $R$-algebra, then there is a distinguished ring homomorphism $R \to A$
and therefore a distinguished scheme morphism $\Spec A \to \Spec R$.
This yields $\Spec$ as a functor $\Spec_R : R / \CommRing \to \Sch / \Spec R$,
and it is easily checked that $\Spec_R$ is fully faithful and essentially on affine schemes over $R$.
We can now state a further property of $\Spec$:
It sends the tensor product of two $R$-algebras to the product of the corresponding schemes:
\[
\Spec_R (A \otimes_R B) \cong \Spec_R A \times_R \Spec_R B.
\]
$\Spec_R$ is fully faithful since $\Spec$ is.

In turn, these properties imply that $\Spec$ sends cogroup objects to group objects
(i.e. Hopf algebras to group schemes), is fully faithful on such,
and has essential image the affine group schemes.

The main player in this story is $\Spec$,
but the storytelling requires almost no property of $\Spec$ at all.
All we use is that $\Spec$ is a fully faithful contravariant functor
from a cocartesian-monoidal category to a cartesian-monoidal one sending pushouts to pullbacks.
The rest is abstract nonsense.


\subsection{Monoidal categories}


\subsection{The over category and algebras}


Let $R$ be a commutative ring.
A commutative $R$-algebra is the data of a commutative ring $A$ along with a ring homomorphism
$R \to A$, called the \emph{structure morphism}.
For two commutative $R$-algebras $A, B$,
an algebra homomorphism $f : A \to B$ is a ring homomorphism that commutes
with the structure morphisms $R \to A, R \to B$.

Similarly, for $S$ a scheme, a $S$-scheme if the data of a scheme $X$ along with a
\emph{structure morphism} $X \to S$

This setup generalises to any category $\mathsf C$ with a distinguished object $B$:
The \emph{under category} of $B$ is the category of pairs $(X, f)$ of an object $X \in \mathsf C$
and a morphism $f : B \to X$, with a morphism $h : (X, f) \to (Y, g)$ being defined asa



\subsection{Group objects}


Recall the definition of a group. A \emph{group structure} on a set $G$ consists of:
\begin{enumerate}
  \item An \emph{identity} $e \in G$.
  \item A \emph{multiplication} $(\cdot * \cdot) : G \times G \to G$.
  \item An \emph{inverse} $(\cdot^{-1}) : G \to G$.
\end{enumerate}

respecting the following \emph{group axioms}:
\begin{enumerate}
  \item For all $g \in G$, $e * g = g$ (and $g * e = g$).
  \item For all $g, h, k \in G$, $(g * h) * k = g * (h * k)$.
  \item For all $g \in G$, $g^{-1} * g = e$ (and $g * g^{-1} = e$).
\end{enumerate}

Groups show up in almost all areas of mathematics, and come in different flavours. For example:
When doing topology, one might ask for the group operations to be continuous,
obtaining the concept of a \emph{topological group}.
In Lie theory, one might want to talk about a group with a manifold structure on it
making the group operations $C^n$-differentiable, i.e a \emph{Lie group}.

These examples share commonalities: Each time, the group comes with some structure,
and the group operations are required to respect that structure.
This observation can be realised categorically:
In any category $\mathsf C$ where $(\cdot \times \cdot)$ and $\{*\}$ make sense,
i.e. with a binary product $(\cdot \otimes \cdot)$ and terminal object $\mathbf 1_C$,
a \emph{group object} $G \in \mathsf C$ consists of:
\begin{enumerate}
  \item A \emph{unit morphism} $\eta : \mathbf 1_C \to G$.
  \item A \emph{multiplication morphism} $\mu : G \otimes G \to G$.
  \item An \emph{inverse morphism} $\iota : G \to G$.
\end{enumerate}

making the following diagrams commute:
{\bf TODO: Add diagrams}

If the following further diagram commutes, then $G$ is a \emph{commutative group object}:
{\bf TODO: Add diagrams}

Analogously to group homomorphisms, if $G$ and $H$ are group objects,
then a morphism $f : G \to H$ is a \emph{group morphism} if the following two diagrams commute:
{\bf TODO: Add diagrams}


\subsection{Group schemes}


A group object in the category of schemes is called a \emph{group scheme}.

The prototypical example of a group scheme is the \emph{standard algebraic torus},
defined as the scheme $\mathbb G_m^n$ along with (morphisms corresponding to):
\begin{enumerate}
  \item The unit morphism $\eta ¬≤: \{*\} \to (\mathbb C^\times)^n$ taking $* \mapsto (1, \dots, 1)$.
  \item The multiplication morphism $\mu : (\mathbb C^\times)^n \times (\mathbb C^\times)^n \to (\mathbb C^\times)^n$
  given by $\mu((t_1, \dots, t_n),(s_1, \dots, s_n)) = (t_1s_1, \dots, t_n s_n)$.
  \item The inverse morphism $\iota : (\mathbb C^\times)^n \to (\mathbb C^\times)^n$
  given by $\iota(t_1, \dots, t_n) = (t_1^{-1}, \dots, t_n^{-1})$.
\end{enumerate}


\subsection{Hopf algebras}


Given a commutative ring $R$, a \emph{commutative $R$-Hopf algebra}
is a commutative $R$-algebra $A$ equipped with
\begin{itemize}
  \item A \emph{counit homomorphism} $\varepsilon: R\to\mathbb{C}$,
  \item A \emph{comultiplication homomorphism} $\Delta: R \to R \otimes R$,
  \item An \emph{antipode homomorphism} $S: R \to R$
\end{itemize}
such that the following diagrams commute:

{\bf TODO: Insert diagrams}

If the following further diagram commutes, then $H$ is a \emph{commutative $R$-Hopf algebra}have furthermore the fo

A \emph{$R$-Hopf algebra} is a $R$-bialgebra $A$ further equipped with an antipode $\iota : A \to A$
such that the following diagram commutes:

TODO: Insert diagram

This looks suspiciously like the diagrams describing a group object.
Indeed they are precisely the same, up to reversing all arrows.
Theref


\section{Hopf algebras}\label{sec:hopf}


TODO(Micha≈Ç)
\section{Group objects}\label{sec:grp}


TODO(Ya√´l)


\section{The Yoneda embedding}\label{sec:yoneda}


TODO(Andrew)


\section{Applications}


\subsection{The pairing of characters and cocharacters}\label{subsec:char-cochar}


TODO(Micha≈Ç)


\subsection{\texorpdfstring{$SO(2)$}{SO2} is a non-split torus over \texorpdfstring{$\R$}{R}}\label{subsec:so2}


TODO(Micha≈Ç)


\section{Conclusion}\label{sec:conclusion}


TODO


\bibliographystyle{plain}
\bibliography{hopf_alg_aff_grp_sch.bib}

\end{document}
