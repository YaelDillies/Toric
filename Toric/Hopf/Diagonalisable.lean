/-
Copyright (c) 2025 Sophie Morel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sophie Morel
-/
import Toric.Hopf.MonoidAlgebra
import Toric.Mathlib.RingTheory.Bialgebra.Basic

universe u

namespace Bialgebra
section CommRing
variable {R G : Type*} {A : Type u} [CommRing R] [Semiring A] [Bialgebra R A]

variable (R A) in
/-- A bialgebra is called diagonalisable if it is isomorphic to a group algebra. -/
@[mk_iff]
class IsDiagonalisable : Prop where
  existsIso : ∃ (G : Type u) (_ : Group G), Nonempty (A ≃ₐc[R] MonoidAlgebra R G)

/-- A group algebra is diagonalisable. -/
instance [Group G] : IsDiagonalisable R (MonoidAlgebra R G) :=
  ⟨⟨ULift G, _, ⟨MonoidAlgebra.domCongrBialgHom R R MulEquiv.ulift.symm⟩⟩⟩

instance [Subsingleton R] : IsDiagonalisable R A := by
  have : Subsingleton A := (algebraMap R A).codomain_trivial
  have := BialgEquiv.ofBijective (Bialgebra.counitBialgHom R A)
    ⟨Function.injective_of_subsingleton _, Function.surjective_to_subsingleton _⟩
  exact ⟨_, _, ⟨this.trans (MonoidAlgebra.bialgEquivOfSubsingleton R PUnit).symm⟩⟩

lemma IsDiagonalisable.ofBialgEquiv {B : Type*} [Semiring B] [Bialgebra R B]
    [hA : IsDiagonalisable R A] (e : A ≃ₐc[R] B) : IsDiagonalisable R B := by
  nontriviality R
  obtain ⟨G, _, ⟨e'⟩⟩ := hA
  replace e := e'.symm.trans e
  have eG := Equiv.ofInjective _ (e.injective.comp MonoidAlgebra.of_injective)
  letI := eG.symm.group
  exact ⟨_, _, ⟨((MonoidAlgebra.domCongrBialgHom R R eG.symm.mulEquiv).trans e).symm⟩⟩

instance : IsDiagonalisable R R := .ofBialgEquiv (MonoidAlgebra.bialgEquivOfSubsingleton R Unit)

/-- A diagonalisable bialgebra is generated by its group-like elements. -/
lemma span_isGroupLikeElem_eq_top_of_isDiagonalisable : IsDiagonalisable R A ->
      Submodule.span R {a : A | IsGroupLikeElem R a} = ⊤ :=
  fun {existsIso := ⟨_, _, h⟩} ↦ MonoidAlgebra.span_isGroupLikeElem_of_iso (Classical.choice h).symm

end CommRing

section Field
variable {K : Type*} {A : Type u} [Field K] [Ring A] [Bialgebra K A]

open MonoidAlgebra

/-- A bialgebra over a field that is generated by its group-like elements is isomorphic
to the group algebra on its group-like elements.
-/
lemma liftGroupLikeBialgHom_bijective_of_span_isGroupLikeElem_eq_top
    (h : Submodule.span K {a : A | IsGroupLikeElem K a} = ⊤) :
    Function.Bijective (liftGroupLikeBialgHom K A) := by
  have : Nontrivial A := Bialgebra.nontrivial K
  set e : GroupLike K A ≃ {a : A | IsGroupLikeElem K a} :=
    {toFun g := ⟨g.1, g.2⟩
     invFun a := ⟨a.2.isUnit.unit, a.2⟩
     left_inv g := by simp
     right_inv a := by simp}
  refine ⟨?_, fun b ↦ ?_⟩
  · rw [RingHom.injective_iff_ker_eq_bot, RingHom.ker_eq_bot_iff_eq_zero]
    intro x hx
    refine (linearIndependent_equiv e).mpr linearIndepOn_isGroupLikeElem.linearIndependent ?_
    simp only [Set.coe_setOf, Set.mem_setOf_eq, id_eq, map_zero]
    rw [Finsupp.linearCombination_apply, ← hx]
    dsimp [liftNC, Finsupp.liftAddHom]
    refine Finsupp.sum_congr (fun a ha ↦ ?_)
    dsimp [Algebra.ofId, e]
    rw [Algebra.smul_def]
  · obtain ⟨x, hx⟩ := (Finsupp.mem_span_iff_linearCombination K {a | IsGroupLikeElem K a} b).mp
      (by rw [h]; exact Submodule.mem_top)
    use x.equivMapDomain e.symm
    rw [← hx, Finsupp.linearCombination_apply]
    dsimp [liftNC, Finsupp.liftAddHom]
    simp only [Finsupp.sum_equivMapDomain, Function.comp_apply]
    refine Finsupp.sum_congr (fun a ha ↦ ?_)
    dsimp [Algebra.ofId, e]
    rw [Algebra.smul_def]

/-- A bialgebra over a field that is generated by its group-like elements is diagonalisable.

This is also true over a commutative ring, but with a more complicated proof. -/
lemma IsDiagonalisable.of_span_isGroupLikeElem_eq_top
    (h : Submodule.span K {a : A | IsGroupLikeElem K a} = ⊤) : IsDiagonalisable K A where
  existsIso := ⟨GroupLike K A, inferInstance, Nonempty.intro ((BialgEquiv.ofBijective _
    (liftGroupLikeBialgHom_bijective_of_span_isGroupLikeElem_eq_top h)).symm)⟩

/-- A bialgebra over a field is diagonalizable if and only if it is generated by its group-like
elements.

This is also true over a commutative ring, but with a more complicated proof. -/
lemma isDiagonalisable_iff_span_isGroupLikeElem_eq_top :
    IsDiagonalisable K A ↔ Submodule.span K {a : A | IsGroupLikeElem K a} = ⊤ :=
  ⟨span_isGroupLikeElem_eq_top_of_isDiagonalisable, .of_span_isGroupLikeElem_eq_top⟩

end Field
end Bialgebra
