/-
Copyright (c) 2025 Yaël Dillies, Michał Mrugała. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yaël Dillies, Michał Mrugała, Sophie Morel
-/
import Mathlib.CategoryTheory.Monoidal.Grp_
import Mathlib.RingTheory.HopfAlgebra.Basic
import Toric.GroupScheme.SpecGrpAlg
import Toric.Hopf.GroupLike
import Mathlib.RingTheory.HopfAlgebra.MonoidAlgebra
import Toric.Mathlib.RingTheory.Bialgebra.Basic
import Toric.GroupScheme.HopfAffine
import Toric.Hopf.MonoidAlgebra
import Toric.Hopf.HopfAlg

open AlgebraicGeometry CategoryTheory Bialgebra Opposite

universe u

namespace HopfAlgebra

variable {R : Type u} {B : Type*} [CommRing R] [Semiring B] [Bialgebra R B]

variable (R B) in
/--
A bialgebra is called diagonalisable if it is isomorphic to the group algebra of a group.
-/
@[mk_iff]
class IsDiagonalisable : Prop where
  existsIso :
    ∃ (A : Type u) (_ : Group A), Nonempty (B ≃ₐc[R] MonoidAlgebra R A)

/--
A group algebra is diagonalisable.
-/
instance {A : Type u} [Group A] : IsDiagonalisable.{u} R (MonoidAlgebra R A) :=
  ⟨⟨A, _, Nonempty.intro (BialgEquiv.refl _ _)⟩⟩

/--
A diagonalisable bialgebra is generated by its group-like elements.
-/
lemma span_isGroupLikeElem_eq_top_of_isDiagonalisable : IsDiagonalisable R B ->
      Submodule.span R {a : B | IsGroupLikeElem R a} = ⊤ :=
  fun {existsIso := ⟨_, _, h⟩} ↦ MonoidAlgebra.span_isGroupLikeElem_of_iso (Classical.choice h).symm

end HopfAlgebra

section Field

namespace HopfAlgebra

open MonoidAlgebra

variable {K : Type u} {B : Type u} [Field K] [Ring B] [Bialgebra K B]

/--
A bialgebra over a field that is generated by its group-like elements is diagonalisable.
(This is also true over a commutative ring, but with a more complicated proof.)
-/
lemma isDiagonalisable_of_span_isGroupLikeElem_eq_top
    (h : Submodule.span K {a : B | IsGroupLikeElem K a} = ⊤) : IsDiagonalisable K B := by
  have : Nontrivial B := Bialgebra.nontrivial K B
  set e : GroupLike K B ≃ {a : B | IsGroupLikeElem K a} :=
    {toFun g := ⟨g.1, g.2⟩
     invFun a := ⟨a.2.isUnit.unit, a.2⟩
     left_inv g := by simp
     right_inv a := by simp}
  refine {existsIso := ⟨GroupLike K B, inferInstance, Nonempty.intro ((BialgEquiv.ofBijective
    (lift_groupLike_bialgHom K B (RingHom.injective _)) ⟨?_, ?_⟩).symm)⟩}
  · rw [RingHom.injective_iff_ker_eq_bot, RingHom.ker_eq_bot_iff_eq_zero]
    intro x hx
    refine (linearIndependent_equiv e).mpr
      (linearIndepOn_isGroupLikeElem (K := K) (A := B)).linearIndependent ?_
    simp only [Set.coe_setOf, Set.mem_setOf_eq, id_eq, map_zero]
    rw [Finsupp.linearCombination_apply, ← hx]
    dsimp [liftNC, Finsupp.liftAddHom]
    refine Finsupp.sum_congr (fun a ha ↦ ?_)
    dsimp [Algebra.ofId, e]
    rw [Algebra.smul_def]
  · intro b
    obtain ⟨x, hx⟩ := (Finsupp.mem_span_iff_linearCombination K {a | IsGroupLikeElem K a} b).mp
      (by rw [h]; exact Submodule.mem_top)
    use x.equivMapDomain e.symm
    rw [← hx, Finsupp.linearCombination_apply]
    dsimp [liftNC, Finsupp.liftAddHom]
    simp only [Finsupp.sum_equivMapDomain, Function.comp_apply]
    refine Finsupp.sum_congr (fun a ha ↦ ?_)
    dsimp [Algebra.ofId, e]
    rw [Algebra.smul_def]

/--
A bialgebra over a field is diagonalizable if and only if it is generated by its group-like
elements.
(This is also true over a commutative ring, but with a more complicated proof.)
-/
lemma isDiagonalisable_iff_span_isGroupLikeElem_eq_top :
    IsDiagonalisable K B ↔
      Submodule.span K {a : B | IsGroupLikeElem K a} = ⊤ :=
  ⟨span_isGroupLikeElem_eq_top_of_isDiagonalisable, isDiagonalisable_of_span_isGroupLikeElem_eq_top⟩

end HopfAlgebra

end Field


namespace AlgebraicGeometry.Scheme
section CommRing
variable {R : CommRingCat.{u}} {G : Over (Spec R)} [Grp_Class G] {A : Type u} [CommGroup A]

variable (G) in
@[mk_iff]
class IsDiagonalisable : Prop where
  existsIso :
    ∃ (A : Type u) (_ : CommGroup A),
      Nonempty <| Grp_.mk' G ≅
      ((specCommGrpAlgebra R).obj <| Opposite.op <| CommGrp.of A)

instance :
    IsDiagonalisable ((specCommGrpAlgebra R).obj <| Opposite.op <| CommGrp.of A).X :=
  ⟨⟨A, _, Nonempty.intro (Iso.refl _)⟩⟩

noncomputable instance : Algebra R (Γ.obj <| op G.left) := sorry

noncomputable instance : HopfAlgebra R (Γ.obj <| op G.left) := by
  have : Grp_Class (Opposite.op (CommAlg.of R (Γ.obj <| op G.left))) := sorry
  exact hopfAlgebra_unop (G := Opposite.op (CommAlg.of R (Γ.obj <| op G.left)))

end CommRing


section Field
variable {K : Type*} [Field K] {G : Over (Spec <| .of K)} [Grp_Class G]

noncomputable instance : HopfAlgebra K (Γ.obj <| op G.left) := by sorry
-- annoyingly, Lean is not able to use the instance on line 37; must find a way to fix this

/-- An affine group `G` over a field `K` is diagonalisable iff it is affine and `Γ(G)` is
`K`-spanned by its group-like elements.

Note that this is more generally true over arbitrary commutative rings, but we do not prove that.
See SGA III, Exposé VIII for more info. -/
lemma isDiagonalisable_iff_span_isGroupLikeElem_eq_top :
    IsDiagonalisable G ↔ IsAffine G.left ∧
      Submodule.span K {a : Γ.obj <| op G.left | IsGroupLikeElem K a} = ⊤ := sorry

end Field
end AlgebraicGeometry.Scheme
