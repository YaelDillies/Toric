/-
Copyright (c) 2025 Justus Springer. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Justus Springer
-/
import Mathlib.Algebra.Order.Nonneg.Module
import Toric.Mathlib.Geometry.Convex.Cone.Dual

/-!
# Polyhedral cones

Given a bilinear pairing `p` between two `R`-modules `M` and `N`, we define
polyhedral cones to be pointed cones in `N` that are the dual of a finite set
in `M` (this means they are the intersection of finitely many halfspaces).

The main statement is that if both `M` and `N` are finite and the pairing is injective
in both arguments, then polyhedral cones are precisely the finitely generated cones, see
`IsPolyhedral_iff_fg`. Moreover, we obtain that the dual of a polyhedral cone is again polyhedral
(`IsPolyhedral_dual_of_IsPolyhedral`) and that the double dual of a polyhedral cone is the
cone itself (`IsPolyhedral_dual_dual`).
-/

open Function
open Submodule hiding span

variable {R ğ•œ M N : Type*}

local notation3 "ğ•œâ‰¥0" => {c : ğ•œ // 0 â‰¤ c}

namespace PointedCone
section PartialOrder
variable [CommRing R] [PartialOrder R] [IsOrderedRing R] [AddCommGroup M] [AddCommGroup N]
  [Module R M] [Module R N] {p : M â†’â‚—[R] N â†’â‚—[R] R} {C Câ‚ Câ‚‚ : PointedCone R N} {s : Set M}

variable (p) in
/-- A cone is polyhedral if it is the dual of a finite set.-/
def IsPolyhedral (C : PointedCone R N) : Prop := âˆƒ s : Set M, s.Finite âˆ§ dual' p s = C

lemma IsPolyhedral_iff_exists_finset : IsPolyhedral p C â†” âˆƒ s : Finset M, dual' p s = C where
  mp := fun âŸ¨_, ht1, ht2âŸ© â†¦ âŸ¨ht1.toFinset, ht1.coe_toFinset.symm â–¸ ht2âŸ©
  mpr := fun âŸ¨s, htâŸ© â†¦ âŸ¨s, s.finite_toSet, htâŸ©

lemma IsPolyhedral.dual_of_finite (hs : s.Finite) : IsPolyhedral p (dual' p s) := âŸ¨s, hs, rflâŸ©

lemma IsPolyhedral.dual_of_fg {C : PointedCone R M} (hC : C.FG) :
    IsPolyhedral p (dual' p (C : Set M)) := by
  obtain âŸ¨s, rflâŸ© := hC; exact âŸ¨s, s.finite_toSet, by rw [dual_span]âŸ©

lemma IsPolyhedral.top : IsPolyhedral p (âŠ¤ : PointedCone R N) := âŸ¨âˆ…, by simpâŸ©

@[simp]
lemma IsPolyhedral.dual_dual_flip (hC : IsPolyhedral p C) :
    dual' p (dual' p.flip (C : Set N)) = C := by
  obtain âŸ¨s, hs, rflâŸ© := hC; exact dual_dual_flip_dual _

@[simp]
lemma IsPolyhedral.dual_flip_dual {C : PointedCone R M} (hC : IsPolyhedral p.flip C) :
    dual' p.flip (dual' p (C : Set M)) = C := IsPolyhedral.dual_dual_flip hC

lemma isPolyhedral.dual_inj (hCâ‚ : IsPolyhedral p Câ‚) (hCâ‚‚ : IsPolyhedral p Câ‚‚) :
    dual' p.flip Câ‚ = dual' p.flip Câ‚‚ â†” Câ‚ = Câ‚‚ where
  mp h := by rw [â† hCâ‚.dual_dual_flip, â† hCâ‚‚.dual_dual_flip, h]
  mpr h := by rw [h]

end PartialOrder

section LinearOrder
variable [Field ğ•œ] [LinearOrder ğ•œ] [IsStrictOrderedRing ğ•œ] [AddCommGroup M] [AddCommGroup N]
  [Module ğ•œ M] [Module ğ•œ N] {p : M â†’â‚—[ğ•œ] N â†’â‚—[ğ•œ] ğ•œ} {C : PointedCone ğ•œ N} {s : Set M} {w : N}

/-- If the module `M` is finite and the pairing induces an injection `N` into `M â†’â‚—[ğ•œ] ğ•œ`,
then the zero cone in `N` is polyhedral. -/
lemma IsPolyhedral.bot [Module.Finite ğ•œ M] (hp : Injective p.flip) :
    IsPolyhedral p (âŠ¥ : PointedCone ğ•œ N) := by
  obtain âŸ¨s, hS : span ğ•œ _ = âŠ¤âŸ© := Module.Finite.fg_top (R := ğ•œâ‰¥0) (M := M)
  refine âŸ¨s, s.finite_toSet, ?_âŸ©
  rw [â† dual_span, hS, Submodule.top_coe, dual_univ hp, Submodule.zero_eq_bot]

variable (p s w) in
/-- A set whose dual cone is `span R {w} âŠ” dual p s`, see `dual_sup_span_singleton_eq_dual` -/
private noncomputable abbrev auxGenSet : Set M :=
  {x âˆˆ s | 0 â‰¤ p x w} âˆª
    .image2 (fun x y â†¦ p x w â€¢ y - p y w â€¢ x) {x âˆˆ s | 0 â‰¤ p x w} {y âˆˆ s | p y w < 0}

omit [IsStrictOrderedRing ğ•œ] in
private lemma auxGenSet_finite (hs : s.Finite) :
    (auxGenSet p s w).Finite := .union (hs.sep _) <| .image2 _ (hs.sep _) (hs.sep _)

private lemma auxGenSet_subset_span :
    (auxGenSet p s w : Set M) âŠ† span ğ•œ (s : Set M) := by
  simp only [Set.union_subset_iff, Set.image2_subset_iff, Set.mem_setOf_eq, and_imp]
  refine âŸ¨subset_trans (fun x hx â†¦ hx.1) subset_span, fun x hxS hxw y hyS hyw â†¦ ?_âŸ©
  simpa [sub_eq_add_neg] using add_mem (smul_mem (span ğ•œ s) âŸ¨p x w, hxwâŸ© (subset_span hyS))
    (smul_mem _ âŸ¨-p y w, neg_nonneg.mpr hyw.leâŸ© (subset_span hxS))

private lemma span_singleton_le_dual_auxGenSet :
    span ğ•œ {w} â‰¤ dual' p (auxGenSet p s w) := by
  simp only [span_singleton_le_iff_mem, mem_dual', Set.mem_union, Set.mem_setOf_eq, Set.mem_image2]
  rintro z (hz | âŸ¨x, âŸ¨hxS, hxwâŸ©, y, âŸ¨hyS, hywâŸ©, rflâŸ©)
  Â· exact hz.2
  Â· simp only [map_sub, map_smul, LinearMap.sub_apply, LinearMap.smul_apply, smul_eq_mul,
      sub_nonneg]
    rw [mul_comm]

/-- The crucial lemma in the proof that a finitely generated cone is polyhedral:
The sum of a polyhedral cone and the cone generated by a single ray is again polyhedral. -/
private lemma dual_auxGenSet (hs : s.Finite) :
    dual' p (auxGenSet p s w) = span ğ•œ {w} âŠ” dual' p s := by
  classical
  apply ge_antisymm
  Â· rw [â† dual_span]
    exact sup_le span_singleton_le_dual_auxGenSet <| dual_le_dual auxGenSet_subset_span
  obtain hSw | hSw := {y âˆˆ s | p y w < 0}.eq_empty_or_nonempty
  Â· simp only [Set.sep_eq_empty_iff_mem_false, not_lt] at hSw
    exact le_sup_of_le_right <| dual_le_dual fun x hx => .inl âŸ¨hx, hSw _ hxâŸ©
  rw [dual_union]
  intro v âŸ¨hv1, hv2âŸ©
  rw [Submodule.mem_sup]
  replace hv2 {x y : M} (hx : x âˆˆ s âˆ§ 0 â‰¤ p x w) (hy : y âˆˆ s âˆ§ p y w < 0) :
      p y w * p x v â‰¤ p y v * p x w := by
    simp only [SetLike.mem_coe, mem_dual', Set.mem_image2, Set.mem_setOf_eq,
      forall_exists_index, and_imp] at hv2
    specialize hv2 x hx.1 hx.2 y hy.1 hy.2 rfl
    simp only [map_sub, map_smul, LinearMap.sub_apply, LinearMap.smul_apply, smul_eq_mul,
      sub_nonneg] at hv2
    nth_rw 2 [mul_comm] at hv2
    exact hv2
  obtain hSv | âŸ¨y, hyâŸ© := {y âˆˆ s | p y w < 0 âˆ§ p y v < 0}.eq_empty_or_nonempty
  Â· simp +contextual only [Set.sep_and, Set.eq_empty_iff_forall_notMem, Set.mem_inter_iff,
      Set.mem_setOf_eq, not_and, true_and, not_lt, and_imp] at hSv
    refine âŸ¨0, zero_mem _, v, fun x hx => ?_, zero_add _âŸ©
    by_cases hxw : 0 â‰¤ p x w
    Â· exact hv1 âŸ¨hx, hxwâŸ©
    Â· exact hSv x hx (lt_of_not_ge hxw)
  lift s to Finset M using hs
  let u : ğ•œ := ({y âˆˆ s | p y w < 0}.image (fun y => p y v * (p y w)â»Â¹)).max' <| by
    simpa [Finset.Nonempty, Set.Nonempty] using hSw.image _
  have hu : 0 â‰¤ u := by
    refine le_trans (mul_nonneg_of_nonpos_of_nonpos hy.2.2.le (inv_nonpos.mpr hy.2.1.le))
      (Finset.le_max' _ (p y v * (p y w)â»Â¹) ?_)
    simp only [Finset.mem_image, Finset.mem_filter]
    exact âŸ¨y, âŸ¨hy.1, hy.2.1âŸ©, rflâŸ©
  refine âŸ¨u â€¢ w, ?_, v - u â€¢ w, fun z hzS â†¦ ?_, add_sub_cancel _ _âŸ©
  Â· rw [â† Nonneg.mk_smul _ hu]
    exact Submodule.smul_mem _ _ (Submodule.subset_span rfl)
  simp only [map_sub, map_smul, smul_eq_mul, sub_nonneg]
  obtain hzw | hzw := lt_or_ge (p z w) 0
  Â· rw [â† _root_.mul_le_mul_right_of_neg (inv_neg''.mpr hzw), mul_inv_cancel_rightâ‚€ hzw.ne]
    exact Finset.le_max' _ (p z v * (p z w)â»Â¹) <|
      Finset.mem_image.mpr âŸ¨z, Finset.mem_filter.mpr âŸ¨hzS, hzwâŸ©, rflâŸ©
  obtain âŸ¨y, hy, t_eq : _ = uâŸ© := Finset.mem_image.mp <|
    ({y âˆˆ s | p y w < 0}.image (fun y => p y v * (p y w)â»Â¹)).max'_mem <| by
      simpa [Finset.Nonempty, Set.Nonempty] using hSw.image _
  rw [Finset.mem_filter] at hy
  rw [â† t_eq, â† _root_.mul_le_mul_left_of_neg hy.2, â† mul_assoc]
  nth_rw 4 [mul_comm]
  rw [mul_inv_cancel_leftâ‚€ hy.2.ne]
  exact hv2 âŸ¨hzS, hzwâŸ© hy

/-- A finitely generated cone is polyhedral. -/
lemma IsPolyhedral.of_fg [Module.Finite ğ•œ M] (hp : Injective p.flip) (hC : C.FG) :
    IsPolyhedral p C := by
  classical
  obtain âŸ¨s, rflâŸ© := hC
  induction s using Finset.induction with
  | empty =>
    rw [Finset.coe_empty, span_empty]
    exact .bot hp
  | @insert w A hwA hA =>
    obtain âŸ¨s, hs, hsAâŸ© := hA
    rw [Finset.coe_insert, Submodule.span_insert, â† hsA, â† dual_auxGenSet hs]
    exact âŸ¨_, auxGenSet_finite hs, rflâŸ©

protected lemma IsPolyhedral.span [Module.Finite ğ•œ M] (hp : Injective p.flip) {s : Set N}
    (hS : s.Finite) : IsPolyhedral p (span ğ•œ s) := .of_fg hp (fg_span hS)

/-- The double dual of a finite set equals the cone generated by that set. -/
lemma dual_dual_eq_span [Module.Finite ğ•œ M] (hp : Injective p.flip) {s : Set N}
    (hS : s.Finite) : dual' p (dual' p.flip s) = span ğ•œ s := by
  nth_rw 2 [â† dual_span]
  exact IsPolyhedral.dual_dual_flip (IsPolyhedral.span hp hS)

/-- A polyhedral cone is finitely generated. -/
lemma fg_of_isPolyhedral [Module.Finite ğ•œ N] [Module.Finite ğ•œ M] (hpâ‚ : Injective p)
    (hpâ‚‚ : Injective p.flip) {C : PointedCone ğ•œ N} (hC : IsPolyhedral p C) : C.FG := by
  obtain âŸ¨s, S_fin, rflâŸ© := hC
  obtain âŸ¨T, T_fin, hTâŸ© :=
    IsPolyhedral.of_fg (LinearMap.flip_flip p â–¸ hpâ‚) (fg_span S_fin)
  rw [â† dual_span, span, â† hT, dual_dual_eq_span hpâ‚‚ T_fin]
  exact Submodule.fg_span T_fin

alias IsPolyhedral.fg := fg_of_isPolyhedral

/-- A cone is polyhedral if and only if it is finitely generated. -/
lemma IsPolyhedral_iff_fg [Module.Finite ğ•œ N] [Module.Finite ğ•œ M] (hpâ‚ : Injective p)
    (hpâ‚‚ : Injective p.flip) : IsPolyhedral p C â†” C.FG :=
  âŸ¨fg_of_isPolyhedral hpâ‚ hpâ‚‚, .of_fg hpâ‚‚âŸ©

/-- The dual of a polyhedral cone is again polyhedral. -/
protected lemma IsPolyhedral.dual [Module.Finite ğ•œ N] [Module.Finite ğ•œ M] (hpâ‚ : Injective p)
    (hpâ‚‚ : Injective p.flip) (hC : IsPolyhedral p C) : IsPolyhedral p.flip (dual' p.flip C) :=
  .dual_of_fg (fg_of_isPolyhedral hpâ‚ hpâ‚‚ hC)

end LinearOrder

end PointedCone
