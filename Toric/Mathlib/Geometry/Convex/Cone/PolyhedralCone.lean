/-
Copyright (c) 2025 Justus Springer. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Justus Springer
-/
import Toric.Mathlib.Geometry.Convex.Cone.Dual
import Toric.Mathlib.Algebra.Order.Nonneg.Module

/-!

# Polyhedral cones

Given a bilinear pairing `p` between two `R`-modules `M` and `N`, we define
polyhedral cones to be pointed cones in `N` that are the dual of a finite set
in `M` (this means they are the intersection of finitely many halfspaces).

The main statement is that if both `M` and `N` are finite and the pairing is injective
in both arguments, then polyhedral cones are precisely the finitely generated cones, see
`IsPolyhedral_iff_fg`. Moreover, we obtain that the dual of a polyhedral cone is again polyhedral
(`IsPolyhedral_dual_of_IsPolyhedral`) and that the double dual of a polyhedral cone is the
cone itself (`IsPolyhedral_dual_dual`).

-/


namespace PointedCone

open Submodule hiding span

section PartialOrder

variable {R M N : Type*} [CommRing R] [PartialOrder R] [IsOrderedRing R] [AddCommGroup M]
  [AddCommGroup N] [Module R M] [Module R N] {p : M â†’â‚—[R] N â†’â‚—[R] R}

variable (p) in
def IsPolyhedral (c : PointedCone R N) : Prop :=
  âˆƒ t : Finset M, c = dual' p t

lemma IsPolyhedral_def {c : PointedCone R N} :
    IsPolyhedral p c â†” âˆƒ t, t.Finite âˆ§ c = dual' p t :=
  âŸ¨fun âŸ¨t, htâŸ© => âŸ¨t, t.finite_toSet, htâŸ©,
   fun âŸ¨_, ht1, ht2âŸ© =>âŸ¨ht1.toFinset, ht1.coe_toFinset.symm â–¸ ht2âŸ©âŸ©

lemma isPolyhedral_dual_of_finite {t : Set M} (h : t.Finite) :
    IsPolyhedral p (dual' p t) := âŸ¨h.toFinset, by simpâŸ©

lemma IsPolyhedral_dual_of_FG {c : PointedCone R M} (hc : c.FG) :
    IsPolyhedral p (dual' p (c : Set M)) := by
  obtain âŸ¨S, rflâŸ© := hc
  rw [dual_span]
  exact âŸ¨S, rflâŸ© 

theorem IsPolyhedral_top : IsPolyhedral p (âŠ¤ : PointedCone R N) := âŸ¨âˆ…, by simpâŸ©

@[simp]
theorem IsPolyhedral.dual_dual_flip {c : PointedCone R N} (hc : IsPolyhedral p c) :
    dual' p (dual' p.flip (c : Set N)) = c := by
  obtain âŸ¨t,rflâŸ© := hc
  exact dual_dual_dual_eq_dual

theorem IsPolyhedral_dual_inj {câ‚ câ‚‚ : PointedCone R N} (hcâ‚ : IsPolyhedral p câ‚)
    (hcâ‚‚ : IsPolyhedral p câ‚‚) : dual' p.flip câ‚ = dual' p.flip câ‚‚ â†” câ‚ = câ‚‚ := by
  rw [â† IsPolyhedral_dual_dual hcâ‚, â† IsPolyhedral_dual_dual hcâ‚‚, h]

end PartialOrder
section LinearOrder

variable {ğ•œ M N : Type*} [Field ğ•œ] [LinearOrder ğ•œ] [IsStrictOrderedRing ğ•œ] [AddCommGroup M]
  [AddCommGroup N] [Module ğ•œ M] [Module ğ•œ N] {p : M â†’â‚—[ğ•œ] N â†’â‚—[ğ•œ] ğ•œ}

/-- If the module `M` is finite and the pairing induces an injection `N` into `M â†’â‚—[ğ•œ] ğ•œ`,
then the zero cone in `N` is polyhedral. -/
theorem IsPolyhedral.bot [Module.Finite ğ•œ M] (hp : Function.Injective p.flip) :
    IsPolyhedral p (âŠ¥ : PointedCone ğ•œ N) := by
  obtain âŸ¨S, hS : span ğ•œ _ = âŠ¤âŸ© := (Nonneg.isFiniteModuleOver ğ•œ M).fg_top
  use S
  rw [â† dual_span, hS, Submodule.top_coe, dual_univ hp, Submodule.zero_eq_bot]

variable (S : Finset M) (w : N)

variable (p) in
/-- A generating set for `span R {w} âŠ” dual p S`, see `dual_sup_span_singleton_eq_dual -/
private noncomputable abbrev dualSupSingletonGenSet : Finset M :=
  open Classical in
  {x âˆˆ S | 0 â‰¤ p x w} âˆª
    .imageâ‚‚ (fun x y => p x w â€¢ y - p y w â€¢ x) {x âˆˆ S | 0 â‰¤ p x w} {y âˆˆ S | p y w < 0}

private lemma dualSupSingletonGenSet_subset_span :
    (dualSupSingletonGenSet p S w : Set M) âŠ† span ğ•œ (S : Set M) := by
  simp only [Finset.coe_union, Finset.coe_filter, Finset.coe_imageâ‚‚, Set.union_subset_iff,
    Set.image2_subset_iff, Set.mem_setOf_eq, SetLike.mem_coe, and_imp]
  refine âŸ¨subset_trans (fun x hx => hx.1) subset_span, ?_âŸ©
  intro x hxS hxw y hyS hyw
  convert add_mem (smul_mem (span ğ•œ S) âŸ¨p x w, hxwâŸ© (subset_span hyS))
    (smul_mem _ âŸ¨-p y w, neg_nonneg.mpr hyw.leâŸ© (subset_span hxS)) using 1
  rw [sub_eq_add_neg, Nonneg.mk_smul, Nonneg.mk_smul, neg_smul]

private lemma span_singleton_le_dualSupSingletonGenSet :
    span ğ•œ {w} â‰¤ dual' p (dualSupSingletonGenSet p S w) := by
  simp only [Finset.coe_union, Finset.coe_filter, Finset.coe_imageâ‚‚, span_singleton_le_iff_mem,
    mem_dual', Set.mem_union, Set.mem_setOf_eq, Set.mem_image2]
  rintro z (hz | âŸ¨x, âŸ¨hxS, hxwâŸ©, y, âŸ¨hyS, hywâŸ©, rflâŸ©)
  Â· exact hz.2
  Â· simp only [map_sub, map_smul, LinearMap.sub_apply, LinearMap.smul_apply, smul_eq_mul,
      sub_nonneg]
    rw [mul_comm]

/-- The crucial lemma in the proof that a finitely generated cone is
polyhedral: The sum of a polyhedral cone and the cone generated by a
single ray is again polyhedral. -/
private lemma dual_sup_span_singleton_eq_dual :
    span ğ•œ {w} âŠ” dual' p S = dual' p (dualSupSingletonGenSet p S w) := by
  classical
  apply le_antisymm
  Â· rw [â†dual_span]
    exact sup_le (span_singleton_le_dualSupSingletonGenSet S w)
      (dual_le_dual (dualSupSingletonGenSet_subset_span S w))
  Â· by_cases hSw : {y âˆˆ S | p y w < 0}.Nonempty
    Â· simp only [Finset.coe_union, Finset.coe_filter, Finset.coe_imageâ‚‚]
      rw [dual_union]
      intro v âŸ¨hv1, hv2âŸ© 
      rw [Submodule.mem_sup]
      replace hv2 {x y : M} (hx : x âˆˆ S âˆ§ 0 â‰¤ p x w) (hy : y âˆˆ S âˆ§ p y w < 0) :
          p y w * p x v â‰¤ p y v * p x w := by
        simp only [SetLike.mem_coe, mem_dual', Set.mem_image2, Set.mem_setOf_eq,
          forall_exists_index, and_imp] at hv2
        specialize hv2 x hx.1 hx.2 y hy.1 hy.2 rfl
        simp only [map_sub, map_smul, LinearMap.sub_apply, LinearMap.smul_apply, smul_eq_mul,
          sub_nonneg] at hv2
        nth_rw 2 [mul_comm] at hv2
        exact hv2
      by_cases hSv : {y âˆˆ S | p y w < 0 âˆ§ p y v < 0}.Nonempty
      Â· let t : ğ•œ := ({y âˆˆ S | p y w < 0}.image (fun y => p y v * (p y w)â»Â¹)).max' <|
          Finset.image_nonempty.mpr hSw
        have ht : 0 â‰¤ t := by
          obtain âŸ¨y, hyâŸ© := hSv
          rw [Finset.mem_filter] at hy
          refine le_trans (mul_nonneg_of_nonpos_of_nonpos hy.2.2.le (inv_nonpos.mpr hy.2.1.le))
            (Finset.le_max' _ (p y v * (p y w)â»Â¹) ?_)
          simp only [Finset.mem_image, Finset.mem_filter]
          exact âŸ¨y, âŸ¨âŸ¨hy.1, hy.2.1âŸ©, rflâŸ©âŸ©
        refine âŸ¨t â€¢ w, ?_, v - t â€¢ w, ?_, add_sub_cancel _ _âŸ©
        Â· rw [â†Nonneg.mk_smul t ht]
          exact Submodule.smul_mem _ _ (Submodule.subset_span rfl)
        Â· intro z hzS
          simp only [map_sub, map_smul, smul_eq_mul, sub_nonneg]
          by_cases hzw_zero : p z w = 0
          Â· rw [hzw_zero, mul_zero]
            exact hv1 âŸ¨hzS, hzw_zero.symm.leâŸ©
          Â· by_cases hzw : 0 < p z w
            Â· obtain âŸ¨y, hy, t_eq : _ = tâŸ© := Finset.mem_image.mp <|
                ({y âˆˆ S | p y w < 0}.image (fun y => p y v * (p y w)â»Â¹)).max'_mem <|
                Finset.image_nonempty.mpr hSw
              rw [Finset.mem_filter] at hy
              rw [â† t_eq, â† _root_.mul_le_mul_left_of_neg hy.2, â† mul_assoc]
              nth_rw 4 [mul_comm]
              rw [mul_inv_cancel_leftâ‚€ hy.2.ne]
              exact hv2 âŸ¨hzS, hzw.leâŸ© hy
            Â· replace hzw : p z w < 0 := lt_of_le_of_ne (le_of_not_lt hzw) hzw_zero
              rw [â† _root_.mul_le_mul_right_of_neg (inv_neg''.mpr hzw),
                mul_inv_cancel_rightâ‚€ hzw_zero]
              exact Finset.le_max' _ ((p z) v * ((p z) w)â»Â¹) <|
                Finset.mem_image.mpr âŸ¨z, Finset.mem_filter.mpr âŸ¨hzS, hzwâŸ©, rflâŸ©
      Â· simp only [Finset.not_nonempty_iff_eq_empty, Finset.eq_empty_iff_forall_not_mem,
          Finset.mem_filter, not_and, not_lt] at hSv
        refine âŸ¨0, zero_mem _, v, fun x hx => ?_, zero_add _âŸ©
        by_cases hxw : 0 â‰¤ p x w
        Â· exact hv1 âŸ¨hx, hxwâŸ©
        Â· exact hSv x hx (lt_of_not_ge hxw)
    Â· simp only [Finset.not_nonempty_iff_eq_empty, Finset.eq_empty_iff_forall_not_mem, 
        Finset.mem_filter, not_and, not_lt] at hSw
      exact le_sup_of_le_right <| dual_le_dual fun x hx =>
        Finset.mem_union_left _ (Finset.mem_filter.mpr âŸ¨hx, hSw x hxâŸ©)

/-- A finitely generated cone is polyhedral. -/
theorem IsPolyhedral_of_fg [Module.Finite ğ•œ M] (hp : Function.Injective p.flip)
    {c : PointedCone ğ•œ N} (hc : c.FG) : IsPolyhedral p c := by
  classical
  obtain âŸ¨S, rflâŸ© := hc
  induction S using Finset.induction with
  | empty =>
    rw [Finset.coe_empty, span_empty]
    exact IsPolyhedral_bot hp
  | @insert w A hwA hA =>
    obtain âŸ¨S, hSâŸ© := hA
    rw [Finset.coe_insert, Submodule.span_insert, hS, dual_sup_span_singleton_eq_dual]
    exact âŸ¨dualSupSingletonGenSet p S w, rflâŸ©

lemma IsPolyhedral_span [Module.Finite ğ•œ M] (hp : Function.Injective p.flip) {S : Set N}
    (hS : S.Finite) : IsPolyhedral p (span ğ•œ S) :=
  IsPolyhedral_of_fg hp (fg_span hS)

/-- The double dual of a finite set equals the cone generated by that set. -/
lemma dual_dual_eq_span [Module.Finite ğ•œ M] (hp : Function.Injective p.flip) {S : Set N}
    (hS : S.Finite) : dual' p (dual' p.flip S) = span ğ•œ S := by
  nth_rw 2 [â†dual_span]
  exact IsPolyhedral_dual_dual (IsPolyhedral_span hp hS)

/-- A polyhedral cone is finitely generated. -/
theorem fg_of_IsPolyhedral [Module.Finite ğ•œ N] [Module.Finite ğ•œ M] (hp1 : Function.Injective p)
    (hp2 : Function.Injective p.flip) {c : PointedCone ğ•œ N} (hc : IsPolyhedral p c) : c.FG := by
  rw [IsPolyhedral_def] at hc
  obtain âŸ¨S, S_fin, rflâŸ© := hc
  obtain âŸ¨T, T_fin, hT : span ğ•œ S = _âŸ© := IsPolyhedral_def.mp <|
    IsPolyhedral_of_fg (LinearMap.flip_flip p â–¸ hp1) (fg_span S_fin)
  rw [â†dual_span, hT, dual_dual_eq_span hp2 T_fin]
  exact Submodule.fg_span T_fin

/-- A cone is polyhedral if and only if it is finitely generated. -/
theorem IsPolyhedral_iff_fg [Module.Finite ğ•œ N] [Module.Finite ğ•œ M] (hp1 : Function.Injective p)
    (hp2 : Function.Injective p.flip) {c : PointedCone ğ•œ N} :
    IsPolyhedral p c â†” c.FG :=
  âŸ¨fg_of_IsPolyhedral hp1 hp2, IsPolyhedral_of_fg hp2âŸ©

/-- The dual of a polyhedral cone is again polyhedral. -/
protected theorem IsPolyhedral.dual [Module.Finite ğ•œ N] [Module.Finite ğ•œ M]
    (hp1 : Function.Injective p) (hp2 : Function.Injective p.flip) {c : PointedCone ğ•œ N}
    (hc : IsPolyhedral p c) : IsPolyhedral p.flip (dual' p.flip c) :=
  IsPolyhedral_dual_of_FG (fg_of_IsPolyhedral hp1 hp2 hc)

end LinearOrder

end PointedCone
