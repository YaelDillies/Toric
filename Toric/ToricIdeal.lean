/-
Copyright (c) 2025 Yaël Dillies, Michał Mrugała. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yaël Dillies, Michał Mrugała
-/
import Mathlib.AlgebraicGeometry.Pullbacks
import Mathlib.FieldTheory.IsAlgClosed.Basic
import Toric.Mathlib.GroupTheory.MonoidLocalization.DivPairs
import Toric.Mathlib.GroupTheory.MonoidLocalization.Basic

/-!
# Toric ideals

This file defines toric ideals.
-/

open AlgebraicGeometry CategoryTheory.Limits

namespace AddMonoidAlgebra
variable {M G R k H : Type*} [AddCommMonoid M] [AddCommGroup G] [AddCommGroup H]
  {f : (⊤ : AddSubmonoid M).LocalizationMap G} {g : (⊤ : AddSubmonoid M).LocalizationMap H}
  {s : AddSubmonoid G} {x : M × M}

section CommRing
variable [CommRing R] {I : Ideal R[M]}

variable (f s) in
/-- The monoid ideal corresponding to a submonoid `s` of the Grothendieck group of a monoid is an
ideal generated by binomials whose exponents differ by an element of `s`. -/
def monoidIdeal : Ideal R[M] := .span <| (fun (a, b) ↦ single a 1 - single b 1) '' s.subPairs f

variable (f g s) in
lemma monoidIdeal_comap :
    monoidIdeal g (s.comap (g.addEquivOfLocalizations f)) = (monoidIdeal f s : Ideal R[M]) := by
  unfold monoidIdeal
  congr!
  exact AddSubmonoid.subPairs_comap ..

/-- An ideal is toric if it's prime and a group ideal. -/
@[mk_iff isToricIdeal_iff_exists_monoidIdeal_eq']
class IsToricIdeal (I : Ideal R[M])  extends I.IsPrime where
  /-- Use `IsToricIdeal.exists_monoidIdeal_eq` instead. -/
  exists_monoidIdeal_eq' :
    ∃ s : AddSubgroup (AddLocalization (⊤ : AddSubmonoid M)),
      monoidIdeal (AddLocalization.addMonoidOf (⊤ : AddSubmonoid M)) s.toAddSubmonoid = I

variable (f) in
lemma isToricIdeal_iff_exists_monoidIdeal_eq :
    IsToricIdeal I ↔ I.IsPrime ∧ ∃ s : AddSubgroup G, monoidIdeal f s.toAddSubmonoid = I := by
  rw [isToricIdeal_iff_exists_monoidIdeal_eq']
  congr! 1
  refine (f.addEquivOfLocalizations <|
    AddLocalization.addMonoidOf _).comapAddSubgroup.toEquiv.exists_congr fun s ↦ ?_
  congr! 1
  simpa using (monoidIdeal_comap ..).symm

namespace IsToricIdeal

alias ⟨exists_monoidIdeal_eq, of_exists_monoidIdeal_eq⟩ := isToricIdeal_iff_exists_monoidIdeal_eq

end IsToricIdeal
end CommRing

section
variable [Field k] [IsAlgClosed k] {I : Ideal k[M]}

lemma isToricIdeal_iff_exists_span_single_sub_single :
    IsToricIdeal I
      ↔ I.IsPrime ∧ ∃ s : Set (M × M), .span ((fun (a, b) ↦ single a 1 - single b 1) '' s) = I where
  mp := by rintro ⟨s, rfl⟩; exact ⟨inferInstance, _, rfl⟩
  mpr := by
    let G := AddLocalization (⊤ : AddSubmonoid M)
    rintro ⟨_, s, hsI⟩
    letI V := Spec (.of  <| k[M] ⧸ I)
    let _ : V.Over (Spec (.of k[M])) := sorry
    let _ : (Spec (.of k[G])).Over (Spec (.of k[M])) := sorry
    let VinterT := pullback (V ↘ Spec (.of k[M])) (Spec (.of k[G]) ↘ Spec (.of k[M]))
    refine ⟨?_⟩
    sorry

end

end AddMonoidAlgebra
